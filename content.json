{"meta":{"title":"谨以此网页，献给一个女孩","subtitle":"李季鸿的博客","description":"如果再相遇，我想我会记得你","author":"Li Jihong","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-06T12:25:11.000Z","updated":"2022-09-07T06:53:33.414Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2022-09-06T12:28:42.000Z","updated":"2022-09-07T07:01:59.870Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-06T12:28:12.000Z","updated":"2022-09-07T07:00:07.599Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2022-09-07T07:19:22.000Z","updated":"2022-09-07T08:39:00.602Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"A sophomore majoring in computer science and technology, from Hainan University, China 姓名：李季鸿 现居：海南，海口 GitHub: BH04250909 QQ: 2182726049 微信: BH04250909"},{"title":"tags","date":"2022-09-06T12:26:50.000Z","updated":"2022-09-07T06:58:32.502Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode刷题","slug":"LeetCode刷题","date":"2022-09-06T13:50:51.159Z","updated":"2022-09-07T06:52:25.850Z","comments":true,"path":"2022/09/06/LeetCode刷题/","link":"","permalink":"http://example.com/2022/09/06/LeetCode%E5%88%B7%E9%A2%98/","excerpt":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;;","text":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 12345678910111213141516171819202122232425class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[0] - interval2[0]; &#125; &#125;); int n = intervals.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; return n - Arrays.stream(dp).max().getAsInt(); &#125;&#125; 方法2.贪心 思路：intervals按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多，intervals的长度减去最多的不重复的区间 就是最少删除区间的个数 复杂度：时间复杂度O(nlogn)，数组排序O(nlogn)，循环一次数组O(n)。空间复杂度O(logn)，排序需要的栈空间 javascript 123456789101112131415161718192021var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; //按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多 intervals.sort((a, b) =&gt; a[1] - b[1]); const n = intervals.length; let right = intervals[0][1]; //right初始化为第一个区间的右边界 let ans = 1; //最多的不重合区间的个数 for (let i = 1; i &lt; n; ++i) &#123; //循环区间数组 if (intervals[i][0] &gt;= right) &#123; //当区间的左边界大于上一个区间的右边界的时候 说明是一对不重合区间 ++ans; //ans加1 right = intervals[i][1]; //更新right &#125; &#125; return n - ans; //intervals的长度减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 123456789101112131415161718192021222324class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[1] - interval2[1]; &#125; &#125;); int n = intervals.length; int right = intervals[0][1]; int ans = 1; for (int i = 1; i &lt; n; ++i) &#123; if (intervals[i][0] &gt;= right) &#123; ++ans; right = intervals[i][1]; &#125; &#125; return n - ans; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}],"author":"Li Jihong"},{"title":"前端笔记","slug":"前端笔记","date":"2022-09-06T04:00:00.000Z","updated":"2022-09-06T04:01:25.467Z","comments":true,"path":"2022/09/06/前端笔记/","link":"","permalink":"http://example.com/2022/09/06/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/","excerpt":"","text":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 表单全选: 1234567891011121314151617181920212223242526&lt;body&gt; &lt;script&gt; var j_caAll = document.getElementById(&#x27;j_caAll&#x27;); //j_caAll是全局选项 var j_tbs = document.getElementById(&#x27;j_tbs&#x27;).getElementsByTagName(&#x27;input&#x27;); //下面所有的复选框 //注册事件 j_caAll.onclick = function()&#123; //this.checked 它可以得到当前复选框的选中状态，如果是true就是选中，如果是false就是未选中 for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].checked = this.checked; &#125; &#125; for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].onclick = function()&#123; var flag = true; //控制全选按钮是否选中 //每次点击下面的复选框都要检查4个小按钮是否被选中 for(var i =0; i &lt; j_tbs.length; i++)&#123; if(!j_tbs[i].checked)&#123;//有一个按钮没有被选中 flag = false; break; //退出for循环，这样可以提高只要效率，因为只要有一个没被选中，就无需循环 &#125; &#125; j_caAll.checked = flag; &#125; &#125; &lt;/script&gt;&lt;/body&gt; Tab栏切换: 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script&gt; var tab_list = document.querySelector(&#x27;.tab_list&#x27;); var lis = tab_list.querySelectorAll(&#x27;li&#x27;); var items = document.querySelectorAll(&#x27;.item&#x27;); //for循环绑定点击事件 for(var i = 0; i&lt; lis.length; i++)&#123; //开始给5个小li 设置索引号 lis[i].setAttribute(&#x27;index&#x27;, i); lis[i].onclick = function()&#123; //1.上的模块选项卡，点击某一个，当前这个底色会是红色，其余不变（排他思想）修改类名的方式 //获取元素 //干掉所有人 其余的li清除class 这个类 for(var i =0 ;i &lt; lis.length; i++)&#123; lis[i].className = &#x27;&#x27;; &#125; //留下我自己 this.className = &#x27;current&#x27;; //2.下面的显示内容模块 var index = this.getAttribute(&#x27;index&#x27;); console.log(index); //干掉所有人 让其余的item 这些div隐藏 for(var i = 0; i &lt; items.length; i++)&#123; items[i].style.display = &#x27;none&#x27;; &#125; //留下我自己 让对应的item 显示出来 items[index].style.display = &#x27;block&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 下拉菜单: 1234567891011121314&lt;script&gt; //1. 获取元素 var nav = document.querySelector(&#x27;.nav&#x27;); var lis = nav.children; //得到四个小li //2. 循环注册事件 for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].onmouseover = function()&#123; this.children[1].style.display = &#x27;block&#x27;; &#125; lis[i].onmouseout = function()&#123; this.children[1].style.display = &#x27;none&#x27;; &#125; &#125; &lt;/script&gt; 简单留言板: 12345678910111213141516171819202122&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value; //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); &#125; &#125; &lt;/script&gt; 删除留言: 123456789101112131415161718192021222324252627282930&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); //(3)删除元素 删除的是当前链接的li 它的父亲 var as = document.querySelector(&#x27;a&#x27;); for(var i=0; i&lt; as.length;i++)&#123; as[i].onclick = function()&#123; //node.removeChild(child); 删除的是li当前所在的li this.parentNode; ul.removeChild(this.parentNode); &#125; &#125; &#125; &#125; &lt;/script&gt; 动态生成表格： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- * @Author: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @Date: 2022-08-17 12:40:22 * @LastEditors: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @LastEditTime: 2022-08-17 14:20:42 * @FilePath: \\JS\\动态生成表格.html * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table &#123; width: 500px; margin: 100px auto; border-collapse: collapse; text-align: center; &#125; td, th &#123; border: 1px solid #333; &#125; thead tr &#123; height: 40px; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspacing=&quot;&#x27;0&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //1.先去准备好学生的数据 var datas =[ &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;javascript&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;C++&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;java&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;linux&#x27;, score:100 &#125;, ]; //2. 往tbody里面创建行：有几个人（通过数组的长度）我们就创建几行 var tbody = document.querySelector(&#x27;tbody&#x27;); for(var i = 0; i &lt; datas.length; i++)&#123;//外面的for循环管是行 tr //1.创建 tr 行 var tr = document.createElement(&#x27;tr&#x27;); tbody.appendChild(tr); //2.行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数 for循环遍历对象 for(var k in datas[i])&#123; //里卖弄的for循环管的是列 td //创建单元格 var td = document.createElement(&#x27;td&#x27;); //吧对象里面的属性值 datas[i][k] 给td // console.log(datas[i][k]); td.innerHTML = datas[i][k]; tr.appendChild(td); &#125; //3.创建有删除2个字的单元格 var td = document.createElement(&#x27;td&#x27;); td.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 tr.appendChild(td); &#125; //4. 删除操作开始 var as = document.querySelectorAll(&#x27;a&#x27;); for(var i = 0; i &lt; as.length; i++)&#123; as[i].onclick = function()&#123; //点击a 删除当前a所在的行(链接的爸爸的爸爸) node.removeChild(child) tbody.removeChild(this.parentNode.parentNode) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[],"author":"Li_Jihong"},{"title":"Hello World","slug":"hello-world","date":"2022-08-24T07:20:48.047Z","updated":"2022-08-24T07:46:10.760Z","comments":true,"path":"2022/08/24/hello-world/","link":"","permalink":"http://example.com/2022/08/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}