{"meta":{"title":"谨以此网页，献给一个女孩","subtitle":"李季鸿的博客","description":"如果再相遇，我想我会记得你","author":"Li Jihong","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-06T12:25:11.000Z","updated":"2022-09-07T06:53:33.414Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2022-09-06T12:28:42.000Z","updated":"2022-09-07T07:01:59.870Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-06T12:28:12.000Z","updated":"2022-09-07T07:00:07.599Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2022-09-07T07:19:22.000Z","updated":"2022-09-07T08:39:00.602Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"A sophomore majoring in computer science and technology, from Hainan University, China 姓名：李季鸿 现居：海南，海口 GitHub: BH04250909 QQ: 2182726049 微信: BH04250909"},{"title":"tags","date":"2022-09-06T12:26:50.000Z","updated":"2022-09-07T06:58:32.502Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ STL库中map的常见操作","slug":"C-STL库中map的常见操作","date":"2022-09-08T06:42:00.000Z","updated":"2022-09-08T07:05:44.807Z","comments":true,"path":"2022/09/08/C-STL库中map的常见操作/","link":"","permalink":"http://example.com/2022/09/08/C-STL%E5%BA%93%E4%B8%ADmap%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"头文件： 123#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; 定义： 123map&lt;char,int&gt;m;//char是下面中括号中元素的数据类型（当然可以换成其他的），//int是等号右边的元素的数据类型。定义什么样的类型是随便的，现在听着可能有点迷，看了下面的赋值可能就懂了 12I love GPLT! It&#x27;s a fun game!aeiou","text":"头文件： 123#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; 定义： 123map&lt;char,int&gt;m;//char是下面中括号中元素的数据类型（当然可以换成其他的），//int是等号右边的元素的数据类型。定义什么样的类型是随便的，现在听着可能有点迷，看了下面的赋值可能就懂了 12I love GPLT! It&#x27;s a fun game!aeiou 123456789101112//对m进行赋值map&lt;char,int&gt;m;m[&#x27;a&#x27;]=4;m[&#x27;d&#x27;]=1;m[&#x27;c&#x27;]=2;//还是对m进行赋值map&lt;int,int&gt;m;m[1]=6;m[3]=4;m[2]=8;//这些数值均没有任何特殊意义，都是随便赋的值 常用函数 1234567891011121314m.push();m.pop(); //emmmmmm,上面这两个函数在map里面都没有m.clear(); //清空m中的所有元素m.empty(); //判断m是否为空m.begin(); //返回指向map头部的迭代器m.end(); //返回指向map尾部的迭代器m.rbegin(); //返回一个指向map尾部的逆向迭代器m.rend(); //返回一个指向map头部的逆向迭代器m.erase(); //删除指定元素m.inser(); //插入元素m.find(); //查找指定元素m.swap(); //交换两个map中的所有元素（注意：两个map中定义的类型需要完全一致） 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; b; //cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl; for(int i=0; i&lt;s2.length(); i++) &#123; b.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; set&lt;char&gt;::iterator it=b.find(s1[i]); if(*it!=s1[i]) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 提前说明： 其实在map内部，已经默认将其中的元素按照中括号中的元素的大小，按照从小到大的顺序排列好了 示例 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;m1; map&lt;char,int&gt;m2; m1[&#x27;q&#x27;] = 1; m1[&#x27;w&#x27;] = 2; m1[&#x27;e&#x27;] = 3; m2[&#x27;a&#x27;] = 4; m2[&#x27;s&#x27;] = 5; m2[&#x27;d&#x27;] = 6; cout&lt;&lt;m1.size()&lt;&lt;endl;//运算结果：3 m1.erase(m1.begin());//删除m1中的第一个元素（指的是中括号中所有元素中最小的，即m1[&#x27;e&#x27;] = 3） map&lt;char,int&gt;::iterator it;//使用迭代器将map中的元素输出 for(it=m1.begin();it!=m1.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;it-&gt;second&lt;&lt;endl;//该语句等价于 cout&lt;&lt;(*it).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*it).second&lt;&lt;endl; //这是map的固定输出格式 &#125; //运算结果：q 1 // w 2 m1.swap(m2);//交换两个map中的所有元素 map&lt;char,int&gt;::reverse_iterator rit; for(rit=m1.rbegin();rit!=m1.rend();rit++)//逆向输出，可以看成从大到小输出 &#123; cout&lt;&lt;(*rit).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*rit).second&lt;&lt;endl; &#125; //运算结果：s 5 // d 5 // a 4return 0;&#125; 下面是整个代码的运算结果：","categories":[{"name":"语法","slug":"语法","permalink":"http://example.com/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-011 A-B","slug":"PTA-天梯赛——L1-011-A-B","date":"2022-09-07T13:40:00.000Z","updated":"2022-09-08T00:09:27.887Z","comments":true,"path":"2022/09/07/PTA-天梯赛——L1-011-A-B/","link":"","permalink":"http://example.com/2022/09/07/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-011-A-B/","excerpt":"PTA-天梯赛——L1-011 A-B 本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。 输入格式： 输入在2行中先后给出字符串A和B。两字符串的长度都不超过10e4 ，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式： 在一行中打印出A−B的结果字符串。 输入样例： 12I love GPLT! It&#x27;s a fun game!aeiou 输出样例： 1I lv GPLT! It&#x27;s fn gm!","text":"PTA-天梯赛——L1-011 A-B 本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。 输入格式： 输入在2行中先后给出字符串A和B。两字符串的长度都不超过10e4 ，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式： 在一行中打印出A−B的结果字符串。 输入样例： 12I love GPLT! It&#x27;s a fun game!aeiou 输出样例： 1I lv GPLT! It&#x27;s fn gm! AC【map】 简单又容易理解，但是我不会想到的啊！！！ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b; getline(cin,a); getline(cin,b); map&lt;char,int&gt; m; for(int i=0; i&lt;b.length(); i++) &#123; m[b[i]]=1; &#125; for(int i=0; i&lt;a.length(); i++) &#123; if(m[a[i]]!=1) &#123; cout&lt;&lt;a[i]; &#125; &#125; return 0;&#125; 【set】 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; s; for(int i=0; i&lt;s2.length(); i++) &#123; s.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; if(s.find(s1[i])==s.end()) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; b; //cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl; for(int i=0; i&lt;s2.length(); i++) &#123; b.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; set&lt;char&gt;::iterator it=b.find(s1[i]); if(*it!=s1[i]) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 普通方法1 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b,c=&quot;&quot;; getline(cin,a); getline(cin,b); for(int i=0; i&lt;a.length(); i++) &#123; bool f=0; for(int j=0; j&lt;b.length(); j++) &#123; if(a[i]==b[j]) f=1; &#125; if(f==0) c=c+a[i]; &#125; cout&lt;&lt;c; return 0;&#125; 普通方法2 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b; getline(cin,a); getline(cin,b); int len=a.length(); for(int i=0; i&lt;b.length(); i++) &#123; char s=b[i]; for(int j=0; j&lt;len; j++) &#123; if(s==a[j]) &#123; for(int k=j; k&lt;len-1; k++) &#123; a[k]=a[k+1]; &#125; len--; j--;//这里要-- 就是排除连着两个一样的字符 &#125; &#125; &#125; for(int i=0; i&lt;len; i++) cout&lt;&lt;a[i]; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"Li Jihong"},{"title":"Hello World","slug":"hello-world","date":"2022-09-07T13:19:11.957Z","updated":"2022-09-08T02:09:05.447Z","comments":true,"path":"2022/09/07/hello-world/","link":"","permalink":"http://example.com/2022/09/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"LeetCode刷题","slug":"LeetCode刷题","date":"2022-09-06T13:50:51.159Z","updated":"2022-09-07T06:52:25.850Z","comments":true,"path":"2022/09/06/LeetCode刷题/","link":"","permalink":"http://example.com/2022/09/06/LeetCode%E5%88%B7%E9%A2%98/","excerpt":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;;","text":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 12345678910111213141516171819202122232425class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[0] - interval2[0]; &#125; &#125;); int n = intervals.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; return n - Arrays.stream(dp).max().getAsInt(); &#125;&#125; 方法2.贪心 思路：intervals按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多，intervals的长度减去最多的不重复的区间 就是最少删除区间的个数 复杂度：时间复杂度O(nlogn)，数组排序O(nlogn)，循环一次数组O(n)。空间复杂度O(logn)，排序需要的栈空间 javascript 123456789101112131415161718192021var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; //按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多 intervals.sort((a, b) =&gt; a[1] - b[1]); const n = intervals.length; let right = intervals[0][1]; //right初始化为第一个区间的右边界 let ans = 1; //最多的不重合区间的个数 for (let i = 1; i &lt; n; ++i) &#123; //循环区间数组 if (intervals[i][0] &gt;= right) &#123; //当区间的左边界大于上一个区间的右边界的时候 说明是一对不重合区间 ++ans; //ans加1 right = intervals[i][1]; //更新right &#125; &#125; return n - ans; //intervals的长度减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 123456789101112131415161718192021222324class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[1] - interval2[1]; &#125; &#125;); int n = intervals.length; int right = intervals[0][1]; int ans = 1; for (int i = 1; i &lt; n; ++i) &#123; if (intervals[i][0] &gt;= right) &#123; ++ans; right = intervals[i][1]; &#125; &#125; return n - ans; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}],"author":"Li Jihong"},{"title":"前端笔记","slug":"前端笔记","date":"2022-09-06T04:00:00.000Z","updated":"2022-09-08T02:08:44.047Z","comments":true,"path":"2022/09/06/前端笔记/","link":"","permalink":"http://example.com/2022/09/06/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/","excerpt":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt;","text":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 表单全选: 1234567891011121314151617181920212223242526&lt;body&gt; &lt;script&gt; var j_caAll = document.getElementById(&#x27;j_caAll&#x27;); //j_caAll是全局选项 var j_tbs = document.getElementById(&#x27;j_tbs&#x27;).getElementsByTagName(&#x27;input&#x27;); //下面所有的复选框 //注册事件 j_caAll.onclick = function()&#123; //this.checked 它可以得到当前复选框的选中状态，如果是true就是选中，如果是false就是未选中 for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].checked = this.checked; &#125; &#125; for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].onclick = function()&#123; var flag = true; //控制全选按钮是否选中 //每次点击下面的复选框都要检查4个小按钮是否被选中 for(var i =0; i &lt; j_tbs.length; i++)&#123; if(!j_tbs[i].checked)&#123;//有一个按钮没有被选中 flag = false; break; //退出for循环，这样可以提高只要效率，因为只要有一个没被选中，就无需循环 &#125; &#125; j_caAll.checked = flag; &#125; &#125; &lt;/script&gt;&lt;/body&gt; Tab栏切换: 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script&gt; var tab_list = document.querySelector(&#x27;.tab_list&#x27;); var lis = tab_list.querySelectorAll(&#x27;li&#x27;); var items = document.querySelectorAll(&#x27;.item&#x27;); //for循环绑定点击事件 for(var i = 0; i&lt; lis.length; i++)&#123; //开始给5个小li 设置索引号 lis[i].setAttribute(&#x27;index&#x27;, i); lis[i].onclick = function()&#123; //1.上的模块选项卡，点击某一个，当前这个底色会是红色，其余不变（排他思想）修改类名的方式 //获取元素 //干掉所有人 其余的li清除class 这个类 for(var i =0 ;i &lt; lis.length; i++)&#123; lis[i].className = &#x27;&#x27;; &#125; //留下我自己 this.className = &#x27;current&#x27;; //2.下面的显示内容模块 var index = this.getAttribute(&#x27;index&#x27;); console.log(index); //干掉所有人 让其余的item 这些div隐藏 for(var i = 0; i &lt; items.length; i++)&#123; items[i].style.display = &#x27;none&#x27;; &#125; //留下我自己 让对应的item 显示出来 items[index].style.display = &#x27;block&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 下拉菜单: 1234567891011121314&lt;script&gt; //1. 获取元素 var nav = document.querySelector(&#x27;.nav&#x27;); var lis = nav.children; //得到四个小li //2. 循环注册事件 for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].onmouseover = function()&#123; this.children[1].style.display = &#x27;block&#x27;; &#125; lis[i].onmouseout = function()&#123; this.children[1].style.display = &#x27;none&#x27;; &#125; &#125; &lt;/script&gt; 简单留言板: 12345678910111213141516171819202122&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value; //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); &#125; &#125; &lt;/script&gt; 删除留言: 123456789101112131415161718192021222324252627282930&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); //(3)删除元素 删除的是当前链接的li 它的父亲 var as = document.querySelector(&#x27;a&#x27;); for(var i=0; i&lt; as.length;i++)&#123; as[i].onclick = function()&#123; //node.removeChild(child); 删除的是li当前所在的li this.parentNode; ul.removeChild(this.parentNode); &#125; &#125; &#125; &#125; &lt;/script&gt; 动态生成表格： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- * @Author: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @Date: 2022-08-17 12:40:22 * @LastEditors: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @LastEditTime: 2022-08-17 14:20:42 * @FilePath: \\JS\\动态生成表格.html * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table &#123; width: 500px; margin: 100px auto; border-collapse: collapse; text-align: center; &#125; td, th &#123; border: 1px solid #333; &#125; thead tr &#123; height: 40px; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspacing=&quot;&#x27;0&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //1.先去准备好学生的数据 var datas =[ &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;javascript&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;C++&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;java&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;linux&#x27;, score:100 &#125;, ]; //2. 往tbody里面创建行：有几个人（通过数组的长度）我们就创建几行 var tbody = document.querySelector(&#x27;tbody&#x27;); for(var i = 0; i &lt; datas.length; i++)&#123;//外面的for循环管是行 tr //1.创建 tr 行 var tr = document.createElement(&#x27;tr&#x27;); tbody.appendChild(tr); //2.行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数 for循环遍历对象 for(var k in datas[i])&#123; //里卖弄的for循环管的是列 td //创建单元格 var td = document.createElement(&#x27;td&#x27;); //吧对象里面的属性值 datas[i][k] 给td // console.log(datas[i][k]); td.innerHTML = datas[i][k]; tr.appendChild(td); &#125; //3.创建有删除2个字的单元格 var td = document.createElement(&#x27;td&#x27;); td.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 tr.appendChild(td); &#125; //4. 删除操作开始 var as = document.querySelectorAll(&#x27;a&#x27;); for(var i = 0; i &lt; as.length; i++)&#123; as[i].onclick = function()&#123; //点击a 删除当前a所在的行(链接的爸爸的爸爸) node.removeChild(child) tbody.removeChild(this.parentNode.parentNode) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[],"author":"Li_Jihong"}],"categories":[{"name":"语法","slug":"语法","permalink":"http://example.com/categories/%E8%AF%AD%E6%B3%95/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}